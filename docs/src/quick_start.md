# Quick Start

For each cluster, Belinda defines the following variables:

 - \\(n\\) is the number of nodes in a cluster
 - \\(m\\) is the number of internal edges in a cluster
 - \\(c\\) is the number of external edges in a cluster

These variables are quite expressive. For example, the degree volume \\(vol(C) = 2 m + c\\)
is the sum of (global) degree of each node inside the cluster, and as shown can be expressed
through two of the above variables. Similarly, the intra-cluster conductance can also be expressed
through the above variables (combined with `g.n`).

## Brief examples of Polars

Polars is a data frames library for Python. Belinda is built upon Polars. For those unfamiliar
with Polars, let's look at some very minimal operations to bridge the gap. For more, check out [their guide](https://pola-rs.github.io/polars-book/user-guide/index.html).

### Creating a data frame

Let's just load the iris dataset:

```python
import polars as pl
df = pl.read_csv("https://j.mp/iriscsv")
df.head(5)
```

**Output:**

```
shape: (5, 5)
┌──────────────┬─────────────┬──────────────┬─────────────┬─────────┐
│ sepal_length ┆ sepal_width ┆ petal_length ┆ petal_width ┆ species │
│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---     │
│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ str     │
╞══════════════╪═════════════╪══════════════╪═════════════╪═════════╡
│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 4.9          ┆ 3.0         ┆ 1.4          ┆ 0.2         ┆ setosa  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 4.7          ┆ 3.2         ┆ 1.3          ┆ 0.2         ┆ setosa  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 4.6          ┆ 3.1         ┆ 1.5          ┆ 0.2         ┆ setosa  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ 5.0          ┆ 3.6         ┆ 1.4          ┆ 0.2         ┆ setosa  │
└──────────────┴─────────────┴──────────────┴─────────────┴─────────┘
```

### Filtering

What are the rows with sepal length greater than 5?

```python
>>> df.filter(pl.col('sepal_length') > 5)
shape: (118, 5)
┌──────────────┬─────────────┬──────────────┬─────────────┬───────────┐
│ sepal_length ┆ sepal_width ┆ petal_length ┆ petal_width ┆ species   │
│ ---          ┆ ---         ┆ ---          ┆ ---         ┆ ---       │
│ f64          ┆ f64         ┆ f64          ┆ f64         ┆ str       │
╞══════════════╪═════════════╪══════════════╪═════════════╪═══════════╡
│ 5.1          ┆ 3.5         ┆ 1.4          ┆ 0.2         ┆ setosa    │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.4          ┆ 3.9         ┆ 1.7          ┆ 0.4         ┆ setosa    │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.4          ┆ 3.7         ┆ 1.5          ┆ 0.2         ┆ setosa    │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.8          ┆ 4.0         ┆ 1.2          ┆ 0.2         ┆ setosa    │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ ...          ┆ ...         ┆ ...          ┆ ...         ┆ ...       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 6.3          ┆ 2.5         ┆ 5.0          ┆ 1.9         ┆ virginica │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 6.5          ┆ 3.0         ┆ 5.2          ┆ 2.0         ┆ virginica │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 6.2          ┆ 3.4         ┆ 5.4          ┆ 2.3         ┆ virginica │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.9          ┆ 3.0         ┆ 5.1          ┆ 1.8         ┆ virginica │
└──────────────┴─────────────┴──────────────┴─────────────┴───────────┘
```

See that Polars operate with this notion of "expressions". See [their guide](https://pola-rs.github.io/polars-book/user-guide/dsl/intro.html) for more info.

### Summary Statistics

What is the average sepal length of the `setosa` species?

```python
>>> df.filter(pl.col('species') == 'setosa').select(pl.col('sepal_length').mean().alias('avg_sepal_length'))
shape: (1, 1)
┌──────────────────┐
│ avg_sepal_length │
│ ---              │
│ f64              │
╞══════════════════╡
│ 5.006            │
└──────────────────┘
```

## Starting with Belinda

Let's get started analyzing some clusters. The goal is to notice how similar
it is manipulating the Iris dataset compared to manipulating a clustering. Assuming that you have the following two files:

 1. `com-amazon.ungraph.txt` - from [SNAP](http://snap.stanford.edu/data/bigdata/communities/com-amazon.ungraph.txt.gz), with comments removed
 2. `com-amazon.leiden.txt` - from running Leiden, default mode (CPM optimization, r = 0.2)

The latter can be generated by running the following command (`runleiden` from [here](https://pypi.org/project/runleiden/)):

```bash
runleiden -i com-amazon.ungraph.txt -r 0.2 -o com-amazon.leiden.txt
```

We have also provided these files for your convenience [here](https://github.com/RuneBlaze/com-amazon-example).

### Basic exploration

```python
import belinda as bl
import polars as pl

g = bl.Graph("com-amazon.ungraph.txt")
g.summary()
```

Output:
```python
shape: (1, 4)
┌────────┬────────┬────────────────┬───────────────────┐
│ n      ┆ m      ┆ num_components ┆ largest_component │
│ ---    ┆ ---    ┆ ---            ┆ ---               │
│ u32    ┆ u64    ┆ u32            ┆ u32               │
╞════════╪════════╪════════════════╪═══════════════════╡
│ 334863 ┆ 925872 ┆ 1              ┆ 334863            │
└────────┴────────┴────────────────┴───────────────────┘
```

So we know that this graph has 334863 nodes and 925872 edges, and that it is a single component.

```python
print(g.n, g.m)
```

**Output:**
```
334863 925872
```

Now let's actually load the clustering. Leiden clusters are given in the so-called "membership" format (explained [here](./clustering_formats.md)).
Belinda's clusterings should always be paired with graphs, so let's also pass in `g`, the graph we just loaded:

```python
c = bl.read_membership(g, "com-amazon.leiden.txt")
c
```

**Output: (truncated)**
```python
shape: (85036, 6)
┌────────┬───────────────┬─────┬─────┬─────┬─────┐
│ label  ┆ nodes         ┆ n   ┆ m   ┆ c   ┆ mcd │
│ ---    ┆ ---           ┆ --- ┆ --- ┆ --- ┆ --- │
│ i64    ┆ binary        ┆ u64 ┆ u64 ┆ u64 ┆ u64 │
╞════════╪═══════════════╪═════╪═════╪═════╪═════╡
│ 32880  ┆ [binary data] ┆ 4   ┆ 5   ┆ 1   ┆ 2   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 29416  ┆ [binary data] ┆ 4   ┆ 3   ┆ 15  ┆ 1   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 10240  ┆ [binary data] ┆ 8   ┆ 21  ┆ 13  ┆ 4   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 137512 ┆ [binary data] ┆ 1   ┆ 0   ┆ 2   ┆ 0   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ ...    ┆ ...           ┆ ... ┆ ... ┆ ... ┆ ... │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 55193  ┆ [binary data] ┆ 2   ┆ 1   ┆ 3   ┆ 1   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
```

Let's take a closer look here. What do these columns and rows mean?
First, Belinda operates under the data model that
this so-called **cluster data frame** has each row representing a cluster, and this cluster data frame is simply implemented as a Polars data frame.
The columns can be described as follows:

 - `label`: the name of this cluster. Note that it need not be an integer.
 - `nodes`: a special column containing all the nodes of this cluster. Although representing this as a `list[int]` might be more intuitive, Belinda at this moment stores a compressed bitmap (roaring bitmap) in this column, therefore shown as an opaque `[binary data]`.
 - `n`, `m`, `c`: these are the variables denoted at the top of this page, the number of nodes, the number of internal edges, the number of external edges relative to this cluster, respectively. An important tip to emphasize again is that these variables generate other statistics, for example \\(\frac{2 m}{n}\\) is the average degree of a node in this cluster.
 - `mcd`: the minimum core degree of this cluster, defined as the minimum degree of the subgraph induced on this cluster.

With that explained, let's take a closer look at this clustering. First, it makes sense to reorder the clusters by sorting decreasingly by cluster sizes. We just reuse what is provided in Polars for us to sort this data frame:

```python
c = c.sort(pl.col('n'), reverse=True)
```

`c` now looks like this (truncated output):
```python
shape: (85036, 6)
┌────────┬───────────────┬─────┬─────┬─────┬─────┐
│ label  ┆ nodes         ┆ n   ┆ m   ┆ c   ┆ mcd │
│ ---    ┆ ---           ┆ --- ┆ --- ┆ --- ┆ --- │
│ i64    ┆ binary        ┆ u64 ┆ u64 ┆ u64 ┆ u64 │
╞════════╪═══════════════╪═════╪═════╪═════╪═════╡
│ 0      ┆ [binary data] ┆ 26  ┆ 115 ┆ 128 ┆ 5   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 8      ┆ [binary data] ┆ 25  ┆ 110 ┆ 537 ┆ 5   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 7      ┆ [binary data] ┆ 25  ┆ 106 ┆ 83  ┆ 5   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 6      ┆ [binary data] ┆ 25  ┆ 107 ┆ 85  ┆ 5   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ ...    ┆ ...           ┆ ... ┆ ... ┆ ... ┆ ... │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
```

Some information we immediately gathered:
 
 1. There are 85036 clusters generated by Leiden
 2. The largest cluster has 26 nodes

At this point we might even conclude that enough is done: getting the number of nodes and edges per each cluster is already not entirely trivial, so let's just export what we gathered to a CSV file:

```python
# "nodes" is of type binary, hence not writable to CSV
>>> c.drop("nodes").write_csv("com-amazon.leiden.stats.csv")
>>> !head com-amazon.leiden.stats.csv
label,n,m,c,mcd
0,26,115,128,5
8,25,110,537,5
7,25,106,83,5
6,25,107,85,5
5,25,107,97,5
4,25,104,13,5
3,25,107,66,4
11,25,101,76,5
10,25,111,62,5
```

Honestly, not bad. One can even write it as a Parquet file for much faster loading next time analyzing this clustering:

```python
# If we want to completely save `c` to load it next time quickly
c.write_parquet("./com-amazon.leiden.parquet")
# pl.read_parquet("./com-amazon.leiden.parquet") retrieves it for later
```

But let's do something more fun this time. Let's just say that we are interested in the larger clusters,
those at least 50th percentile in size. We can do this by filtering the data frame:

```python
>>> c50 = c.filter(pl.col('n') >= pl.col('n').quantile(0.5))
>>> c50
shape: (49716, 6)
┌───────┬───────────────┬─────┬─────┬─────┬─────┐
│ label ┆ nodes         ┆ n   ┆ m   ┆ c   ┆ mcd │
│ ---   ┆ ---           ┆ --- ┆ --- ┆ --- ┆ --- │
│ i64   ┆ binary        ┆ u64 ┆ u64 ┆ u64 ┆ u64 │
╞═══════╪═══════════════╪═════╪═════╪═════╪═════╡
│ 0     ┆ [binary data] ┆ 26  ┆ 115 ┆ 128 ┆ 5   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 8     ┆ [binary data] ┆ 25  ┆ 110 ┆ 537 ┆ 5   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 7     ┆ [binary data] ┆ 25  ┆ 106 ┆ 83  ┆ 5   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 6     ┆ [binary data] ┆ 25  ┆ 107 ┆ 85  ┆ 5   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ ...   ┆ ...           ┆ ... ┆ ... ┆ ... ┆ ... │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
```

Let's export this file back into the membership format, since it does seem like a widely used format for clustering:

```python
>>> bl.write_membership(g, c50, "./com-amazon.leiden.50.txt")
>>> !head com-amazon.leiden.50.txt
1	18951
88160	18951
118052	35215
161555	18951
244916	19694
346495	18951
444232	47430
447165	39248
500600	18951
2	3680
```